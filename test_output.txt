python : INFO:src.autogen_adapters.agent_factory:AgentFactory initialized with 8 agent configs
At line:1 char:59
+ ... em.Text.Encoding]::UTF8; python test_function_calling.py 2>&1 | Out-F ...
+                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (INFO:src.autoge...8 agent configs:String) [], RemoteExcepti 
   on
    + FullyQualifiedErrorId : NativeCommandError
 
INFO:src.autogen_adapters.groupchat_factory:GroupChatFactory initialized with 6 chat configs
INFO:mcp.registry:Registered tool: github
INFO:mcp.registry:Registered tool: filesystem
INFO:mcp.registry:Registered tool: memory
INFO:mcp.registry:Registered tool: slack
INFO:src.autogen_adapters.function_registry:FunctionRegistry initialized with 4 tool categories
INFO:src.autogen_adapters.conversation_manager:ConversationManager initialized with 8 workflows
INFO:src.autogen_adapters.conversation_manager:Initializing ConversationManager components...
INFO:mcp.github:Connecting to http://localhost:3000/mcp/github
INFO:mcp.github:Connected to github MCP server
INFO:mcp.manager:[OK] Github MCP tool initialized
INFO:mcp.filesystem:Connecting to http://localhost:3001/mcp/filesystem
INFO:mcp.filesystem:Connected to filesystem MCP server
INFO:mcp.manager:[OK] Filesystem MCP tool initialized
INFO:mcp.memory:Connecting to http://localhost:3002/mcp/memory
INFO:mcp.memory:Connected to memory MCP server
INFO:mcp.manager:[OK] Memory MCP tool initialized
INFO:mcp.slack:Connecting to http://localhost:3003/mcp/slack
INFO:mcp.slack:Connected to slack MCP server
INFO:mcp.manager:[OK] Slack MCP tool initialized
INFO:mcp.manager:Initialized 4 MCP tools
INFO:src.autogen_adapters.function_registry:MCP tools initialized
INFO:src.autogen_adapters.function_registry:Registered function: create_pull_request
INFO:src.autogen_adapters.function_registry:Registered function: get_pull_request
INFO:src.autogen_adapters.function_registry:Registered function: create_issue
INFO:src.autogen_adapters.function_registry:Registered function: search_code
INFO:src.autogen_adapters.function_registry:Registered function: get_file_contents
INFO:src.autogen_adapters.function_registry:Registered function: read_file
INFO:src.autogen_adapters.function_registry:Registered function: write_file
INFO:src.autogen_adapters.function_registry:Registered function: list_directory
INFO:src.autogen_adapters.function_registry:Registered function: search_files
INFO:src.autogen_adapters.function_registry:Registered function: store_memory
INFO:src.autogen_adapters.function_registry:Registered function: retrieve_memory
INFO:src.autogen_adapters.function_registry:Registered function: search_memory
INFO:src.autogen_adapters.function_registry:Registered function: send_message
INFO:src.autogen_adapters.function_registry:Registered function: send_notification
INFO:src.autogen_adapters.function_registry:Registered 14 functions total
INFO:src.autogen_adapters.function_registry:Registered 14 MCP tool functions
INFO:src.autogen_adapters.agent_factory:Creating TeachableAgent: code_analyzer
WARNING:src.autogen_adapters.agent_factory:TeachableAgent not available, creating AssistantAgent instead 
for code_analyzer
INFO:src.autogen_adapters.agent_factory:Created agent: code_analyzer
INFO:src.autogen_adapters.agent_factory:Added 9 tools to llm_config for code_analyzer
INFO:src.autogen_adapters.agent_factory:Creating AssistantAgent: security_auditor
INFO:src.autogen_adapters.agent_factory:Created agent: security_auditor
INFO:src.autogen_adapters.agent_factory:Added 1 tools to llm_config for security_auditor
INFO:src.autogen_adapters.agent_factory:Creating AssistantAgent: documentation_agent
INFO:src.autogen_adapters.agent_factory:Created agent: documentation_agent
INFO:src.autogen_adapters.agent_factory:Added 4 tools to llm_config for documentation_agent
INFO:src.autogen_adapters.agent_factory:Creating AssistantAgent: deployment_agent
INFO:src.autogen_adapters.agent_factory:Created agent: deployment_agent
INFO:src.autogen_adapters.agent_factory:Added 5 tools to llm_config for deployment_agent
INFO:src.autogen_adapters.agent_factory:Creating AssistantAgent: research_agent
INFO:src.autogen_adapters.agent_factory:Created agent: research_agent
INFO:src.autogen_adapters.agent_factory:Added 6 tools to llm_config for research_agent
INFO:src.autogen_adapters.agent_factory:Creating AssistantAgent: project_manager
INFO:src.autogen_adapters.agent_factory:Created agent: project_manager
INFO:src.autogen_adapters.agent_factory:Added 6 tools to llm_config for project_manager
INFO:src.autogen_adapters.agent_factory:Creating UserProxyAgent: executor
INFO:src.autogen_adapters.agent_factory:Created agent: executor
INFO:src.autogen_adapters.agent_factory:Creating UserProxyAgent: user_proxy_executor
INFO:src.autogen_adapters.agent_factory:Created agent: user_proxy_executor
INFO:src.autogen_adapters.agent_factory:Created 8 agents
INFO:src.autogen_adapters.function_registry:Registered get_pull_request for calling with agent: 
code_analyzer
INFO:src.autogen_adapters.function_registry:Registered search_code for calling with agent: code_analyzer
INFO:src.autogen_adapters.function_registry:Registered get_file_contents for calling with agent: 
code_analyzer
INFO:src.autogen_adapters.function_registry:Registered read_file for calling with agent: code_analyzer
INFO:src.autogen_adapters.function_registry:Registered list_directory for calling with agent: 
code_analyzer
INFO:src.autogen_adapters.function_registry:Registered search_files for calling with agent: code_analyzer
INFO:src.autogen_adapters.function_registry:Registered store_memory for calling with agent: code_analyzer
INFO:src.autogen_adapters.function_registry:Registered retrieve_memory for calling with agent: 
code_analyzer
INFO:src.autogen_adapters.function_registry:Registered search_memory for calling with agent: 
code_analyzer
INFO:src.autogen_adapters.conversation_manager:Registered functions with agent: code_analyzer
INFO:src.autogen_adapters.function_registry:Registered send_notification for calling with agent: 
security_auditor
INFO:src.autogen_adapters.conversation_manager:Registered functions with agent: security_auditor
INFO:src.autogen_adapters.function_registry:Registered get_file_contents for calling with agent: 
documentation_agent
INFO:src.autogen_adapters.function_registry:Registered read_file for calling with agent: 
documentation_agent
INFO:src.autogen_adapters.function_registry:Registered write_file for calling with agent: 
documentation_agent
INFO:src.autogen_adapters.function_registry:Registered list_directory for calling with agent: 
documentation_agent
INFO:src.autogen_adapters.conversation_manager:Registered functions with agent: documentation_agent
INFO:src.autogen_adapters.function_registry:Registered create_pull_request for calling with agent: 
deployment_agent
INFO:src.autogen_adapters.function_registry:Registered create_issue for calling with agent: 
deployment_agent
INFO:src.autogen_adapters.function_registry:Registered write_file for calling with agent: 
deployment_agent
INFO:src.autogen_adapters.function_registry:Registered send_message for calling with agent: 
deployment_agent
INFO:src.autogen_adapters.function_registry:Registered send_notification for calling with agent: 
deployment_agent
INFO:src.autogen_adapters.conversation_manager:Registered functions with agent: deployment_agent
INFO:src.autogen_adapters.function_registry:Registered search_code for calling with agent: research_agent
INFO:src.autogen_adapters.function_registry:Registered read_file for calling with agent: research_agent
INFO:src.autogen_adapters.function_registry:Registered search_files for calling with agent: 
research_agent
INFO:src.autogen_adapters.function_registry:Registered store_memory for calling with agent: 
research_agent
INFO:src.autogen_adapters.function_registry:Registered retrieve_memory for calling with agent: 
research_agent
INFO:src.autogen_adapters.function_registry:Registered search_memory for calling with agent: 
research_agent
INFO:src.autogen_adapters.conversation_manager:Registered functions with agent: research_agent
INFO:src.autogen_adapters.function_registry:Registered create_pull_request for calling with agent: 
project_manager
INFO:src.autogen_adapters.function_registry:Registered get_pull_request for calling with agent: 
project_manager
INFO:src.autogen_adapters.function_registry:Registered create_issue for calling with agent: 
project_manager
INFO:src.autogen_adapters.function_registry:Registered store_memory for calling with agent: 
project_manager
INFO:src.autogen_adapters.function_registry:Registered search_memory for calling with agent: 
project_manager
INFO:src.autogen_adapters.function_registry:Registered send_message for calling with agent: 
project_manager
INFO:src.autogen_adapters.conversation_manager:Registered functions with agent: project_manager
INFO:src.autogen_adapters.function_registry:Registered 14 functions for execution with UserProxyAgent: 
executor
INFO:src.autogen_adapters.conversation_manager:Registered functions with agent: executor
INFO:src.autogen_adapters.function_registry:Registered 14 functions for execution with UserProxyAgent: 
user_proxy_executor
INFO:src.autogen_adapters.conversation_manager:Registered functions with agent: user_proxy_executor
INFO:src.autogen_adapters.conversation_manager:ConversationManager initialization complete
=== Testing Function Calling Fix ===

Initializing AutoGen system...
[OK] System initialized

Checking function registration...
[OK] UserProxyAgent: Executor
[OK] CodeAnalyzer: CodeAnalyzer

[OK] UserProxyAgent has 14 functions registered for execution
  Functions: ['create_pull_request', 'get_pull_request', 'create_issue', 'search_code', 'get_file_contents']...

Running quick_code_review workflow...
CodeAnalyzer (to Executor):

TASK: Code Review

File to review: ./main.py
Focus areas: error handling, security

INSTRUCTIONS FOR CODE ANALYZER:
1. Read the file at ./main.py to get the actual code content
2. Analyze the REAL code from that file (not examples)
3. Provide specific feedback on:
   - Error handling and edge cases
   - Security vulnerabilities
   - Performance issues
   - Code quality and best practices
4. Reference specific line numbers and code sections in your review
5. Do NOT execute the code, only analyze it

Please start by reading the file.


--------------------------------------------------------------------------------
Executor (to CodeAnalyzer):



--------------------------------------------------------------------------------
INFO:httpx:HTTP Request: POST https://openrouter.ai/api/v1/chat/completions "HTTP/1.1 200 OK"
[autogen.oai.client: 12-17 13:42:00] {695} WARNING - Model openai/gpt-oss-120b:free is not found. The cost will be 0. In your config_list, add field {"price" : [prompt_price_per_1k, completion_token_price_per_1k]} for customized pricing.
WARNING:autogen.oai.client:Model openai/gpt-oss-120b:free is not found. The cost will be 0. In your 
config_list, add field {"price" : [prompt_price_per_1k, completion_token_price_per_1k]} for customized 
pricing.
CodeAnalyzer (to Executor):


***** Suggested tool call (chatcmpl-tool-827cd6d4b81951e4): read_file *****
Arguments: 
{"file_path":"./main.py"}
***************************************************************************

--------------------------------------------------------------------------------

>>>>>>>> EXECUTING FUNCTION read_file...
Call ID: chatcmpl-tool-827cd6d4b81951e4
Input arguments: {'file_path': './main.py'}

>>>>>>>> EXECUTED FUNCTION read_file...
Call ID: chatcmpl-tool-827cd6d4b81951e4
Input arguments: {'file_path': './main.py'}
Output:
#!/usr/bin/env python3
"""
Intelligent Development Assistant - AutoGen Edition
Multi-Agent AI System with AutoGen, Gemini, Groq & MCP Servers

Version: 2.0.0 (AutoGen)
Framework: Microsoft AutoGen
Models: Google Gemini 2.5 Flash & Groq
"""

import asyncio
import logging
import sys
import shlex
from pathlib import Path
from dotenv import load_dotenv

from rich.console import Console
from rich.panel import Panel
from rich.table import Table

# Import AutoGen adapters
from src.autogen_adapters.conversation_manager import create_conversation_manager

# Import security
from src.security.input_validator import validate_parameters, validate_workflow_name, ValidationError
from src.security.log_sanitizer import install_log_filter

console = Console()

# Load environment variables
load_dotenv()


BANNER = """
==================================================================

       INTELLIGENT DEVELOPMENT ASSISTANT
       Multi-Agent AI System with AutoGen, Gemini & Groq

       Version: 2.0.0 (AutoGen Edition)
       Agents: Code Analyzer | Security | Docs | Deploy | PM
       Models: Gemini 2.5 Flash | Groq Mixtral & Llama

==================================================================
"""


def setup_logging():
    """Setup logging configuration"""
    # Create logs directory if it doesn't exist
    Path('logs').mkdir(exist_ok=True)

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('logs/autogen_dev_assistant.log'),
            logging.StreamHandler()
        ]
    )

    # Install sensitive data filter to prevent API keys/secrets in logs
    install_log_filter(
        logger=None,  # Install on root logger
        redact_emails=False,
        redact_ips=False
    )


async def main():
    """Main entry point"""
    try:
        # Setup logging
        setup_logging()
        logger = logging.getLogger(__name__)

        # Display banner
        console.print(BANNER, style="bold cyan")
        console.print()

        # Initialize conversation manager
        console.print("[bold blue]Initializing AutoGen System...[/bold blue]")

        try:
            manager = await create_conversation_manager()
            console.print("[green][OK] AutoGen system initialized successfully[/green]")
            console.print()
        except Exception as e:
            console.print(f"[red][ERROR] Failed to initialize: {e}[/red]")
            logger.error(f"Initialization failed: {e}", exc_info=True)
            return 1

        # Show available workflows
        console.print("[bold]Available Workflows:[/bold]")
        workflows = manager.list_workflows()

        table = Table(show_header=True, header_style="bold magenta")
        table.add_column("Workflow", style="cyan")
        table.add_column("Description")

        workflow_descriptions = {
            "code_analysis": "Comprehensive code review with security & quality checks",
            "security_audit": "Deep security vulnerability assessment",
            "documentation_generation": "Generate project documentation",
            "deployment": "Execute deployment to target environment",
            "research": "Research technologies and best practices",
            "quick_code_review": "Quick code review for small changes",
            "quick_documentation": "Quick documentation update",
        }

        for workflow in workflows:
            desc = workflow_descriptions.get(workflow, "N/A")
            table.add_row(workflow, desc)

        console.print(table)
        console.print()

        # Interactive mode
        console.print("[bold green]Interactive Mode[/bold green]")
        console.print("[dim]Commands: run, list, history, help, exit[/dim]")
        console.print()

        while True:
            try:
                # Get user input
                user_input = console.input("[bold cyan]>>> [/bold cyan]").strip()

                if not user_input:
                    continue

                # Parse command (using shlex to properly handle quoted strings)
                try:
                    parts = shlex.split(user_input)
                except ValueError:
                    # Fallback to simple split if shlex fails
                    parts = user_input.split()
                command = parts[0].lower()

                if command in ["exit", "quit", "q"]:
                    console.print("[yellow]Goodbye![/yellow]")
                    break

                elif command == "help":
                    console.print(Panel("""
[bold]Available Commands:[/bold]

  [cyan]run <workflow> [params...][/cyan]
    Execute a workflow
    Example: run code_analysis code_path=./src

  [cyan]list[/cyan]
    List available workflows

  [cyan]history[/cyan]
    Show recent workflow executions

  [cyan]help[/cyan]
    Show this help message

  [cyan]exit[/cyan]
    Exit the application
                    """, title="Help"))

                elif command == "list":
                    console.print("\n[bold]Available Workflows:[/bold]")
                    for workflow in workflows:
                        console.print(f"  â€¢ {workflow}")
                    console.print()

                elif command == "history":
                    history = manager.get_workflow_history(10)

                    if not history:
                        console.print("[dim]No execution history available[/dim]")
                    else:
                        hist_table = Table(show_header=True, header_style="bold magenta")
                        hist_table.add_column("Workflow")
                        hist_table.add_column("Status")
                        hist_table.add_column("Duration")

                        for entry in history:
                            status_icon = "[OK]" if entry["status"] == "success" else "[FAIL]"
                            duration = f"{entry['duration_seconds']:.2f}s"
                            hist_table.add_row(
                                entry["workflow_name"],
                                f"{status_icon} {entry['status']}",
                                duration
                            )

                        console.print(hist_table)

                elif command == "run":
                    if len(parts) < 2:
                        console.print("[red]Usage: run <workflow> [param=value ...][/red]")
                        continue

                    workflow_name = parts[1]

                    # Parse parameters
                    variables = {}
                    for arg in parts[2:]:
                        if "=" in arg:
                            key, value = arg.split("=", 1)
                            variables[key] = value

                    try:
                        # Validate workflow name
                        workflow_name = validate_workflow_name(workflow_name)

                        # Validate parameters
                        if variables:
                            variables = validate_parameters(variables)

                    except ValidationError as e:
                        console.print(f"[red]Validation error: {e}[/red]")
                        logger.warning(f"Input validation failed: {e}")
                        continue

                    console.print(f"\n[bold]Executing workflow:[/bold] {workflow_name}")
                    if variables:
                        console.print(f"[dim]Parameters: {variables}[/dim]")
                    console.print()

                    try:
                        # Execute workflow
                        result = await manager.execute_workflow(workflow_name, variables)

                        # Display result
                        if result.status == "success":
                            console.print(f"[green][OK] Workflow completed successfully[/green]")
                        elif result.status == "partial":
                            console.print(f"[yellow][WARN] Workflow completed with warnings[/yellow]")
                        else:
                            console.print(f"[red][ERROR] Workflow failed[/red]")

                        console.print(f"\n[bold]Summary:[/bold]")
                        console.print(result.summary)
                        console.print(f"\n[dim]Duration: {result.duration_seconds:.2f}s[/dim]")
                        console.print(f"[dim]Tasks: {result.tasks_completed} completed, {result.tasks_failed} failed[/dim]")

                        if result.error:
                            console.print(f"\n[red]Error: {result.error}[/red]")

                    except Exception as e:
                        console.print(f"[red]Error executing workflow: {e}[/red]")
                        logger.error(f"Workflow execution error: {e}", exc_info=True)

                    console.print()

                else:
                    console.print(f"[yellow]Unknown command: {command}[/yellow]")
                    console.print("[dim]Type 'help' for available commands[/dim]")

            except KeyboardInterrupt:
                console.print("\n[yellow]Use 'exit' to quit[/yellow]")
            except EOFError:
                break
            except Exception as e:
                console.print(f"[red]Error: {e}[/red]")
                logger.error(f"Command error: {e}", exc_info=True)

        return 0

    except Exception as e:
        console.print(f"[bold red]Fatal error: {e}[/bold red]")
        logging.exception("Fatal error")
        return 1


if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        console.print("\n[yellow]Interrupted by user[/yellow]")
        sys.exit(130)

Executor (to CodeAnalyzer):

***** Response from calling tool (chatcmpl-tool-827cd6d4b81951e4) *****
#!/usr/bin/env python3
"""
Intelligent Development Assistant - AutoGen Edition
Multi-Agent AI System with AutoGen, Gemini, Groq & MCP Servers

Version: 2.0.0 (AutoGen)
Framework: Microsoft AutoGen
Models: Google Gemini 2.5 Flash & Groq
"""

import asyncio
import logging
import sys
import shlex
from pathlib import Path
from dotenv import load_dotenv

from rich.console import Console
from rich.panel import Panel
from rich.table import Table

# Import AutoGen adapters
from src.autogen_adapters.conversation_manager import create_conversation_manager

# Import security
from src.security.input_validator import validate_parameters, validate_workflow_name, ValidationError
from src.security.log_sanitizer import install_log_filter

console = Console()

# Load environment variables
load_dotenv()


BANNER = """
==================================================================

       INTELLIGENT DEVELOPMENT ASSISTANT
       Multi-Agent AI System with AutoGen, Gemini & Groq

       Version: 2.0.0 (AutoGen Edition)
       Agents: Code Analyzer | Security | Docs | Deploy | PM
       Models: Gemini 2.5 Flash | Groq Mixtral & Llama

==================================================================
"""


def setup_logging():
    """Setup logging configuration"""
    # Create logs directory if it doesn't exist
    Path('logs').mkdir(exist_ok=True)

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('logs/autogen_dev_assistant.log'),
            logging.StreamHandler()
        ]
    )

    # Install sensitive data filter to prevent API keys/secrets in logs
    install_log_filter(
        logger=None,  # Install on root logger
        redact_emails=False,
        redact_ips=False
    )


async def main():
    """Main entry point"""
    try:
        # Setup logging
        setup_logging()
        logger = logging.getLogger(__name__)

        # Display banner
        console.print(BANNER, style="bold cyan")
        console.print()

        # Initialize conversation manager
        console.print("[bold blue]Initializing AutoGen System...[/bold blue]")

        try:
            manager = await create_conversation_manager()
            console.print("[green][OK] AutoGen system initialized successfully[/green]")
            console.print()
        except Exception as e:
            console.print(f"[red][ERROR] Failed to initialize: {e}[/red]")
            logger.error(f"Initialization failed: {e}", exc_info=True)
            return 1

        # Show available workflows
        console.print("[bold]Available Workflows:[/bold]")
        workflows = manager.list_workflows()

        table = Table(show_header=True, header_style="bold magenta")
        table.add_column("Workflow", style="cyan")
        table.add_column("Description")

        workflow_descriptions = {
            "code_analysis": "Comprehensive code review with security & quality checks",
            "security_audit": "Deep security vulnerability assessment",
            "documentation_generation": "Generate project documentation",
            "deployment": "Execute deployment to target environment",
            "research": "Research technologies and best practices",
            "quick_code_review": "Quick code review for small changes",
            "quick_documentation": "Quick documentation update",
        }

        for workflow in workflows:
            desc = workflow_descriptions.get(workflow, "N/A")
            table.add_row(workflow, desc)

        console.print(table)
        console.print()

        # Interactive mode
        console.print("[bold green]Interactive Mode[/bold green]")
        console.print("[dim]Commands: run, list, history, help, exit[/dim]")
        console.print()

        while True:
            try:
                # Get user input
                user_input = console.input("[bold cyan]>>> [/bold cyan]").strip()

                if not user_input:
                    continue

                # Parse command (using shlex to properly handle quoted strings)
                try:
                    parts = shlex.split(user_input)
                except ValueError:
                    # Fallback to simple split if shlex fails
                    parts = user_input.split()
                command = parts[0].lower()

                if command in ["exit", "quit", "q"]:
                    console.print("[yellow]Goodbye![/yellow]")
                    break

                elif command == "help":
                    console.print(Panel("""
[bold]Available Commands:[/bold]

  [cyan]run <workflow> [params...][/cyan]
    Execute a workflow
    Example: run code_analysis code_path=./src

  [cyan]list[/cyan]
    List available workflows

  [cyan]history[/cyan]
    Show recent workflow executions

  [cyan]help[/cyan]
    Show this help message

  [cyan]exit[/cyan]
    Exit the application
                    """, title="Help"))

                elif command == "list":
                    console.print("\n[bold]Available Workflows:[/bold]")
                    for workflow in workflows:
                        console.print(f"  â€¢ {workflow}")
                    console.print()

                elif command == "history":
                    history = manager.get_workflow_history(10)

                    if not history:
                        console.print("[dim]No execution history available[/dim]")
                    else:
                        hist_table = Table(show_header=True, header_style="bold magenta")
                        hist_table.add_column("Workflow")
                        hist_table.add_column("Status")
                        hist_table.add_column("Duration")

                        for entry in history:
                            status_icon = "[OK]" if entry["status"] == "success" else "[FAIL]"
                            duration = f"{entry['duration_seconds']:.2f}s"
                            hist_table.add_row(
                                entry["workflow_name"],
                                f"{status_icon} {entry['status']}",
                                duration
                            )

                        console.print(hist_table)

                elif command == "run":
                    if len(parts) < 2:
                        console.print("[red]Usage: run <workflow> [param=value ...][/red]")
                        continue

                    workflow_name = parts[1]

                    # Parse parameters
                    variables = {}
                    for arg in parts[2:]:
                        if "=" in arg:
                            key, value = arg.split("=", 1)
                            variables[key] = value

                    try:
                        # Validate workflow name
                        workflow_name = validate_workflow_name(workflow_name)

                        # Validate parameters
                        if variables:
                            variables = validate_parameters(variables)

                    except ValidationError as e:
                        console.print(f"[red]Validation error: {e}[/red]")
                        logger.warning(f"Input validation failed: {e}")
                        continue

                    console.print(f"\n[bold]Executing workflow:[/bold] {workflow_name}")
                    if variables:
                        console.print(f"[dim]Parameters: {variables}[/dim]")
                    console.print()

                    try:
                        # Execute workflow
                        result = await manager.execute_workflow(workflow_name, variables)

                        # Display result
                        if result.status == "success":
                            console.print(f"[green][OK] Workflow completed successfully[/green]")
                        elif result.status == "partial":
                            console.print(f"[yellow][WARN] Workflow completed with warnings[/yellow]")
                        else:
                            console.print(f"[red][ERROR] Workflow failed[/red]")

                        console.print(f"\n[bold]Summary:[/bold]")
                        console.print(result.summary)
                        console.print(f"\n[dim]Duration: {result.duration_seconds:.2f}s[/dim]")
                        console.print(f"[dim]Tasks: {result.tasks_completed} completed, {result.tasks_failed} failed[/dim]")

                        if result.error:
                            console.print(f"\n[red]Error: {result.error}[/red]")

                    except Exception as e:
                        console.print(f"[red]Error executing workflow: {e}[/red]")
                        logger.error(f"Workflow execution error: {e}", exc_info=True)

                    console.print()

                else:
                    console.print(f"[yellow]Unknown command: {command}[/yellow]")
                    console.print("[dim]Type 'help' for available commands[/dim]")

            except KeyboardInterrupt:
                console.print("\n[yellow]Use 'exit' to quit[/yellow]")
            except EOFError:
                break
            except Exception as e:
                console.print(f"[red]Error: {e}[/red]")
                logger.error(f"Command error: {e}", exc_info=True)

        return 0

    except Exception as e:
        console.print(f"[bold red]Fatal error: {e}[/bold red]")
        logging.exception("Fatal error")
        return 1


if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        console.print("\n[yellow]Interrupted by user[/yellow]")
        sys.exit(130)

***********************************************************************

--------------------------------------------------------------------------------
INFO:httpx:HTTP Request: POST https://openrouter.ai/api/v1/chat/completions "HTTP/1.1 200 OK"
[autogen.oai.client: 12-17 13:42:35] {695} WARNING - Model openai/gpt-oss-120b:free is not found. The cost will be 0. In your config_list, add field {"price" : [prompt_price_per_1k, completion_token_price_per_1k]} for customized pricing.
WARNING:autogen.oai.client:Model openai/gpt-oss-120b:free is not found. The cost will be 0. In your 
config_list, add field {"price" : [prompt_price_per_1k, completion_token_price_per_1k]} for customized 
pricing.
CodeAnalyzer (to Executor):

**Code Review – `main.py`**  
*Focus: error handling, security, performance, and overall code quality*  

---

## 1.  Logging & Sensitive‑Data Handling  

| Line | Issue / Observation | Recommendation |
|------|----------------------|----------------|
| **48‑68** | `install_log_filter` is called with `redact_emails=False` and `redact_ips=False`.  The comment says “prevent API keys/secrets in logs”, yet no redaction is actually enabled. | Enable redaction for the most common secrets (emails, IPs, API keys, JWTs, etc.). Example: `install_log_filter(logger=None, redact_emails=True, redact_ips=True, redact_api_keys=True)`. |
| **51** | `Path('logs').mkdir(exist_ok=True)` creates the directory in the current working directory, which may be a location without write permission (e.g., when the script is launched from a read‑only mount). | Use `Path.cwd() / 'logs'` and handle `PermissionError` explicitly, falling back to a temporary directory (`tempfile.gettempdir()`). |
| **53‑60** | `logging.basicConfig` is called **after** the directory creation, but the `FileHandler` will raise an exception if the file cannot be opened (e.g., permission denied). The exception would be caught by the outer `try/except` (line 72) and reported as a *fatal* error, but the user gets no hint why logging failed. | Wrap the `basicConfig` call in its own `try/except` and log the problem to `stderr` before exiting. |
| **75** | `logger = logging.getLogger(__name__)` is defined **after** `setup_logging`. If `setup_logging` throws, `logger` never exists, yet later `except Exception as e:` blocks (e.g., line 259) still reference `logger`. | Move the logger creation **before** any code that may raise, or guard every `logger.*` call with `if 'logger' in locals():`. |

---

## 2.  Environment Variable Loading  

| Line | Issue | Recommendation |
|------|-------|----------------|
| **32** | `load_dotenv()` is called without checking its return value. If the `.env` file is missing or malformed, the application may run with missing configuration (e.g., API keys). | Capture the return (`found = load_dotenv()`) and warn the user if no env file is found. Consider raising a custom `ConfigurationError` for required variables. |

---

## 3.  User Input Parsing & Validation  

| Line | Issue | Recommendation |
|------|-------|----------------|
| **133‑136** | Fallback to `user_input.split()` when `shlex.split` fails. This can break quoted arguments (e.g., `run workflow "param=some value"`). | Instead of silently falling back, report the parsing error to the user and ask for corrected input. |
| **141‑142** | `command = parts[0].lower()` assumes `parts` is non‑empty after the split. The earlier `if not user_input: continue` protects most cases, but a malformed input that results in an empty list (e.g., only whitespace) would raise `IndexError`. | Add a guard: `if not parts: continue` before accessing `parts[0]`. |
| **164‑168** | The bullet character `â€¢` is a UTF‑8 mis‑encoding. It will appear as garbage on many terminals. | Replace with a proper Unicode bullet (`•`) or a plain hyphen. |
| **199‑205** | Parameter parsing only accepts `key=value`. No validation of the *key* format (e.g., empty key, spaces) is performed before handing it to `validate_parameters`. | Strip whitespace from `key`, reject empty keys, and optionally enforce a whitelist of allowed parameter names. |
| **210‑213** | `validate_parameters` is called **only if** `variables` is non‑empty. If the validator expects a dict and raises on missing required keys, the code will silently skip validation when the user supplies *no* parameters, potentially allowing a workflow to run with default unsafe values. | Always call `validate_parameters` (even with an empty dict) if the workflow expects mandatory parameters, or let the validator raise a clear error. |
| **214‑218** | `ValidationError` is caught, but the original exception type (e.g., `ValueError` from a malformed parameter) would bypass this block and be caught by the generic `except Exception` later, resulting in a generic “Error” message. | Expand the except clause to include `ValueError` or catch a base `Exception` from the validator and treat it as a validation failure. |

---

## 4.  Workflow Execution & Result Handling  

| Line | Issue | Recommendation |
|------|-------|----------------|
| **226** | `await manager.execute_workflow(workflow_name, variables)` is called without any timeout or cancellation handling. A misbehaving workflow could block the interactive session indefinitely. | Wrap the call in `asyncio.wait_for(..., timeout=MAX_SECONDS)` and handle `asyncio.TimeoutError` with a user‑friendly

--------------------------------------------------------------------------------

>>>>>>>> TERMINATING RUN (b1f9d8eb-4102-45d9-93cc-4f88f998669b): Maximum number of consecutive auto-replies reached

>>>>>>>> TERMINATING RUN (42d37061-b100-446f-865c-a166974eda37): Maximum turns (3) reached
INFO:src.autogen_adapters.conversation_manager:Workflow 'quick_code_review' completed in 38.37s

=== Results ===
Status: success
Duration: 38.37s
Messages: 5

Summary:
Two-agent conversation between code_analyzer and user_proxy_executor completed with 5 messages
